function [ alphas, values ] = hagerzhang_linesearch( problem, x, s, options_hzls )

% function [ alphas, values, state, stat_hzls ] = hagerzhang_linesearch( x, s, options_hzls )
% Purpose: Performs Hager-Zhang linesearch.
% References: [1] Hager and Zhang, Algorithm 851: CG DESCENT, a Conjugate
%                 Gradient Method with Guaranteed Descent, ACM Trans. Math.
%                 Softw., 32 (2006), pp. 113â€“137.
%             [2] https://julianlsolvers.github.io/LineSearches.jl/stable/index.html
% Created:     2019.09.27
% Last change: 2022.10.24

%   Oct 24, 2022:
%       Adaptation to the code for Riem. CG.
%   May 27, 2020:
%       Replaced function_phidphi with feval(problem.eval_phidphi, ...).
%   May 23, 2020:
%       Code cleanup.

if options_hzls.display
    fprintf('+---------------------------------------------------------------------------------------+\n');
    fprintf('|                                 Hager-Zhang linesearch                                |\n');
    fprintf('+---------------------------------------------------------------------------------------+\n');
end

%--------------------------------------------------------------------------
% L0
%--------------------------------------------------------------------------
% I0-I2 in HZ paper, denoted initial(k) in the HZ paper
%--------------------------------------------------------------------------
state = initialguess( problem, x, s, options_hzls );
c = state.alpha;
if options_hzls.display
    fprintf('initial c = %.3e.\n', c );
end
%--------------------------------------------------------------------------
% END of I0-I2
%--------------------------------------------------------------------------

% [ phi_0, dphi_0 ] = eval_phidphi(Da, Db, Dg, c);
[ phi_0, dphi_0 ] = feval( options_hzls.eval_phidphi, problem, x, s, c );

if not( isfinite(phi_0) && isfinite(dphi_0) )
    error('Value and slope at step length = 0 must be finite.');
end
if dphi_0 >= eps*abs(phi_0)
    warning('Search direction is not a direction of descent; dphi_0 = %.4e, (eps*abs(phi_0)) = %.4e.', dphi_0, eps * abs(phi_0) );
elseif dphi_0 >= 0
    alphas = eps;
    values = phi_0;
    return;
end

% Prevent values of x_new = x+c.s that are likely to make phi(x_new) infinite
iterfinitemax = ceil(-log2(eps));
alphas = 0;        % for bisection
values = phi_0;
slopes = dphi_0;

% For condition (4.3) in Hager and Zhang, 2005.
phi_lim = phi_0 + options_hzls.epsilon * abs(phi_0); % phi_0 + eps * abs(phi_0);

assert( isfinite(c) && c <= options_hzls.alphamax );

% [ phi_c, dphi_c, stat_hzls ] = feval(problem.eval_phidphi, problem, x, Dg, c, stat_hzls );

% [ phi_c, dphi_c ] = eval_phidphi(Da, Db, Dg, c);
[ phi_c, dphi_c ] = feval( options_hzls.eval_phidphi, problem, x, s, c );

iterfinite = 1;

while ( not(isfinite(phi_c) && isfinite(dphi_c)) && (iterfinite < iterfinitemax) )
    iterfinite = iterfinite + 1;
    c = options_hzls.psi3 * c;    % Contracts c, since psi3 = 0.1
    % [ phi_c, dphi_c, stat_hzls ] = feval(problem.eval_phidphi, problem, x, Dg, c, stat_hzls );
    % [ phi_c, dphi_c ] = eval_phidphi(Da, Db, Dg, c);
    [ phi_c, dphi_c ] = feval( options_hzls.eval_phidphi, problem, x, s, c );
end

if not(isfinite(phi_c) && isfinite(dphi_c))
    warning('Failed to achieve finite new evaluation point, using alpha = 0.\n')
    % mayterminate = false; % reset in case another initial guess is used next
    alphas = 0;
    values = phi_0;
    return;
end
alphas = [alphas; c];
values = [values; phi_c];
slopes = [slopes; dphi_c];

% If c was generated by quadratic interpolation, check whether it satisfies
% the Wolfe conditions
if satisfies_wolfe( c, phi_c, dphi_c, phi_0, dphi_0, phi_lim, options_hzls )
    if options_hzls.display % & LINESEARCH > 0
        fprintf('Wolfe condition satisfied on point alpha = %.4e.\n', c );
    end
    % MS, 27.11.2019: Save the accepted c for future use.
%     info_global(current_lev,column_idx) = c;
    return;   % return c, phi_c
end

%--------------------------------------------------------------------------
% [a,b] = bracket(c)
%--------------------------------------------------------------------------
% Initial bracketing step (HZ, stages B0-B3).
% The following code is used to generate an initial interval [a,b]
% satisfying the opposite slope condition (29), beginning with the initial
% guess [0,c].
isbracketed = false;
ia = 1;
ib = 2;
assert( length(alphas) == 2 );
iter = 1;
while ( ~isbracketed && iter < options_hzls.linesearchmax )
    if options_hzls.display
        fprintf('bracketing: ia = %d, ib = %d, c = %.3e, phi_c = %.3e, dphi_c = %.3e.\n', ...
            ia, ib, c, phi_c, dphi_c );
    end
    %----------------------------------------------------------------------
    % B1
    if dphi_c >= 0
        % We've reached the upward slope, so we have b; examine previous
        % values to find a
        ib = length(alphas);
        for i = (ib - 1):-1:1
            if values(i) <= phi_lim
                ia = i;
                break;
            end
        end
        isbracketed = true;
        %------------------------------------------------------------------
        % B2
    elseif values(end) > phi_lim
        % The value is higher, but the slope is downward, so we must
        % have crested over the peak. Use bisection.
        ib = length(alphas);   % This guarantees that we enter bisect with \bar{b} = c
        ia = 1;                % This guarantees that we enter bisect with \bar{a} = 0
        
        if ( c ~= alphas(ib) ) || ( slopes(ib) >= 0 )
            error(['c = ', num2str(c)]);
        end
        
        % This implements U3a-c
        [ ia, ib, alphas, values, slopes ] = bisect( alphas, values, ...
            slopes, ia, ib, phi_lim, x, s, options_hzls );

        isbracketed = true;
    else
        %------------------------------------------------------------------
        % B3
        % We will still go downhill, expand the interval and try again.
        % Reaching this branch means that dphi_c < 0 and phi_c <= phi_0 + eps_k
        % So cold = c has a lower objective than phi_0 up to epsilon.
        % This makes it a viable step to return if bracketing fails.
        
        % Bracketing can fail if no cold < c <= alphamax can be found with
        % finite phi_c and dphi_c. Going back to the loop with c = cold
        % will only result in infinite cycling. So returning (cold, phi_cold)
        % and exiting the line search is the best move.
        cold = c;
        phi_cold = phi_c;
        if cold >= options_hzls.alphamax
            return;
        end
        % c_{j+1} = rho * c_{j}, where rho is the growth factor for the
        % bracketing interval. Hager and Zhang suggest to use rho = 5.
        c = options_hzls.rho * c;
        if options_hzls.display
            fprintf('B3: Expand the interval and try again. cold = %.3e, c = %.3e.\n', cold, c );
        end
        if c > options_hzls.alphamax
            c = options_hzls.alphamax;
            if options_hzls.display
                fprintf('B3: exceeding alphamax, using c = alphamax = %.3e, cold = %.3e.', options_hzls.alphamax, cold );
            end
        end
        
%         [ phi_c, dphi_c, stat_hzls ] = feval(problem.eval_phidphi, problem, x, Dg, c, stat_hzls );
        [ phi_c, dphi_c ] = feval( options_hzls.eval_phidphi, problem, x, s, c );
%         [ phi_c, dphi_c ] = eval_phidphi(Da, Db, Dg, c);
        
        iterfinite = 1;
        
        while not(isfinite(phi_c) && isfinite(dphi_c)) && c > ( cold + eps ) && iterfinite < iterfinitemax
            options_hzls.alphamax = c; % shrinks alphamax, assumes that steps >= c can never have finite phi_c and dphi_c
            iterfinite = iterfinite + 1;
            if options_hzls.display
                fprintf('B3: non-finite value, bisection.\n')
            end
            c = (cold + c) / 2;
%             [ phi_c, dphi_c, stat_hzls ] = feval(problem.eval_phidphi, problem, x, Dg, c, stat_hzls );
%             [ phi_c, dphi_c ] = eval_phidphi(Da, Db, Dg, c);
            [ phi_c, dphi_c ] = feval( options_hzls.eval_phidphi, problem, x, s, c );
        end
        if not( isfinite(phi_c) && isfinite(dphi_c) )
            if options_hzls.display
                fprintf('Warning: failed to expand interval to bracket with finite values. If this happens frequently, check your function and gradient.')
                fprintf('c = %.3f, alphamax = %.3f, phi_c = %.3f, dphi_c = %.3f.\n', c, options_hzls.alphamax, phi_c, dphi_c);
            end
            alphas = cold;
            values = phi_cold;
            return;
        end
        alphas = [alphas; c];
        values = [values; phi_c];
        slopes = [slopes; dphi_c];
    end   % End of B3
    iter = iter + 1;
end   % End of the while loop
if slopes(ia) * slopes(ib) < 0
    if options_hzls.display
        fprintf('End of bracketing: The opposite slope condition is enforced: dphi(a) = %.4e; dphi(b) = %.4e.\n', slopes(ia), slopes(ib) );
    end
else
end
%--------------------------------------------------------------------------
% End of [a,b] = bracket(c) and end of L0
%--------------------------------------------------------------------------

%--------------------------------------------------------------------------
% Main loop of the linesearch algorithm (L1-L2-L3)
%--------------------------------------------------------------------------
while iter < options_hzls.linesearchmax
    a = alphas(ia);
    b = alphas(ib);
    % assert( b > a );
    if options_hzls.display
        fprintf('linesearch: ia = %d, ib = %d, a = %.3e, b = %.3e, phi(a) = %.3e, phi(b) = %.3e.\n', ia, ib, a, b, values(ia), values(ib) );
    end
    if b - a <= eps(b)
        alphas = a;
        values = values(ia);
        return;
    end
    %----------------------------------------------------------------------
    % L1: Take the secant step
    %----------------------------------------------------------------------
    [ iswolfe, iA, iB, alphas, values, slopes ] = secant2( alphas, values, ...
        slopes, ia, ib, phi_lim, x, s, problem, options_hzls );
    if options_hzls.display
        fprintf('L1: END of secant2.\n');
    end
    if iswolfe
        alphas = alphas(iA);
        values = values(iA);
        return;
    end
    A = alphas(iA);
    B = alphas(iB);
    assert( B > A );
    
    if ( B - A ) < options_hzls.gamma * (b - a)
        if options_hzls.display
            fprintf('L3: secant succeeded.\n');
        end
        if ( values(ia) + eps ) >= values(ib) && ( values(iA) + eps ) >= values(iB)
            % It's so flat, secant didn't do anything useful, time to quit
            if options_hzls.display
                fprintf('Linesearch: secant suggests it is flat.\n');
            end
            return;   % return A, values(iA)
        end
        ia = iA;
        ib = iB;
    else
        %------------------------------------------------------------------
        % L2: bisection step, then update
        %------------------------------------------------------------------
        % Secant is converging too slowly, use bisection
        if options_hzls.display
            fprintf('L2: secant failed, using bisection.\n');
        end
        
        % Bisection:
        c = (A + B) / 2;
        
        % [ phi_c, dphi_c, stat_hzls ] = feval(problem.eval_phidphi, problem, x, Dg, c, stat_hzls );
        % [ phi_c, dphi_c ] = eval_phidphi(Da, Db, Dg, c);
        [ phi_c, dphi_c ] = feval( options_hzls.eval_phidphi, problem, x, s, c );

        assert ( isfinite(phi_c) && isfinite(dphi_c) );
        alphas = [alphas; c];
        values = [values; phi_c];
        slopes = [slopes; dphi_c];
        
        [ ia, ib, alphas, values, slopes ] = update_hz( alphas, values, ...
            slopes, iA, iB, length(alphas), phi_lim, x, s, options_hzls );
    end
    %----------------------------------------------------------------------
    % L3: increment iter and go to L1
    %----------------------------------------------------------------------
    iter = iter + 1;
end
%--------------------------------------------------------------------------
% End of main loop of linesearch algorithm
%--------------------------------------------------------------------------

warning('Linesearch failed to converge, reached maximum iterations linesearchmax = %d.', options_hzls.linesearchmax )

end